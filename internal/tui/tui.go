package tui

import (
	"context"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"github.com/charmbracelet/bubbles/key"
	"github.com/charmbracelet/bubbles/spinner"
	"github.com/charmbracelet/bubbles/viewport"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/iheanyi/agentctl/pkg/aliases"
	"github.com/iheanyi/agentctl/pkg/config"
	"github.com/iheanyi/agentctl/pkg/mcp"
	"github.com/iheanyi/agentctl/pkg/profile"
	"github.com/iheanyi/agentctl/pkg/secrets"
	"github.com/iheanyi/agentctl/pkg/sync"
)

// FilterMode represents the current filter for the server list
type FilterMode int

const (
	FilterAll FilterMode = iota
	FilterInstalled
	FilterAvailable
	FilterDisabled
)

// LogEntry represents a single log entry in the log panel
type LogEntry struct {
	Time    time.Time
	Level   string // info, warn, error, success
	Message string
}

// Model is the Bubble Tea model for the TUI
type Model struct {
	// Data
	cfg           *config.Config
	allServers    []Server // All servers (installed + available)
	filteredItems []Server // Currently visible items after filtering
	selected      map[string]bool

	// State
	cursor      int
	filterMode  FilterMode
	searchQuery string
	searching   bool
	profile     string // Current profile name

	// Log panel
	logs         []LogEntry
	logExpanded  bool
	logViewport  viewport.Model

	// UI state
	showHelp   bool
	quitting   bool
	width      int
	height     int
	spinner    spinner.Model
	statusMsg  string

	// Profile picker
	showProfilePicker bool
	profiles          []*profile.Profile
	profileCursor     int

	// Keys
	keys keyMap
}

// New creates a new TUI model
func New() (*Model, error) {
	cfg, err := config.LoadWithProject()
	if err != nil {
		return nil, fmt.Errorf("failed to load config: %w", err)
	}

	s := spinner.New()
	s.Spinner = spinner.Dot
	s.Style = SpinnerStyle

	m := &Model{
		cfg:        cfg,
		selected:   make(map[string]bool),
		filterMode: FilterAll,
		profile:    "default",
		logs:       []LogEntry{},
		keys:       newKeyMap(),
		spinner:    s,
	}

	// Load profiles
	profilesDir := filepath.Join(cfg.ConfigDir, "profiles")
	if profiles, err := profile.LoadAll(profilesDir); err == nil {
		m.profiles = profiles
	}

	// Use default profile from settings if available
	if cfg.Settings.DefaultProfile != "" {
		m.profile = cfg.Settings.DefaultProfile
	}

	m.buildServerList()
	m.applyFilter()
	m.addLog("info", "agentctl UI ready")

	return m, nil
}

// buildServerList constructs the unified server list from config and aliases
func (m *Model) buildServerList() {
	m.allServers = []Server{}
	installedNames := make(map[string]bool)

	// Add installed servers
	for name, server := range m.cfg.Servers {
		installedNames[name] = true

		status := ServerStatusInstalled
		if server.Disabled {
			status = ServerStatusDisabled
		}

		transport := string(server.Transport)
		if transport == "" {
			transport = "stdio"
		}

		m.allServers = append(m.allServers, Server{
			Name:         name,
			Desc:         "", // Generated by FormatServerDescription from transport/command
			Status:       status,
			Health:       HealthStatusUnknown,
			Transport:    transport,
			Command:      server.Command,
			ServerConfig: server,
		})
	}

	// Add available servers from aliases (not yet installed)
	allAliases := aliases.List()
	for name, alias := range allAliases {
		if installedNames[name] {
			continue
		}

		transport := alias.Transport
		if transport == "" {
			transport = "stdio"
		}

		m.allServers = append(m.allServers, Server{
			Name:        name,
			Desc:        alias.Description,
			Status:      ServerStatusAvailable,
			Health:      HealthStatusUnknown,
			Transport:   transport,
			AliasConfig: &alias,
		})
	}

	// Sort: installed first, then alphabetically within each group
	sort.Slice(m.allServers, func(i, j int) bool {
		// Installed/disabled before available
		if m.allServers[i].Status != ServerStatusAvailable && m.allServers[j].Status == ServerStatusAvailable {
			return true
		}
		if m.allServers[i].Status == ServerStatusAvailable && m.allServers[j].Status != ServerStatusAvailable {
			return false
		}
		// Alphabetically within group
		return m.allServers[i].Name < m.allServers[j].Name
	})
}

// applyFilter updates filteredItems based on current filter mode and search
func (m *Model) applyFilter() {
	m.filteredItems = []Server{}

	for _, s := range m.allServers {
		// Apply filter mode
		switch m.filterMode {
		case FilterInstalled:
			if s.Status != ServerStatusInstalled {
				continue
			}
		case FilterAvailable:
			if s.Status != ServerStatusAvailable {
				continue
			}
		case FilterDisabled:
			if s.Status != ServerStatusDisabled {
				continue
			}
		}

		// Apply search query
		if m.searchQuery != "" {
			if !strings.Contains(strings.ToLower(s.Name), strings.ToLower(m.searchQuery)) &&
				!strings.Contains(strings.ToLower(s.Desc), strings.ToLower(m.searchQuery)) {
				continue
			}
		}

		m.filteredItems = append(m.filteredItems, s)
	}

	// Adjust cursor if needed
	if m.cursor >= len(m.filteredItems) {
		m.cursor = max(0, len(m.filteredItems)-1)
	}
}

// addLog adds a log entry to the log panel
func (m *Model) addLog(level, message string) {
	m.logs = append(m.logs, LogEntry{
		Time:    time.Now(),
		Level:   level,
		Message: message,
	})
	// Keep only last 100 entries
	if len(m.logs) > 100 {
		m.logs = m.logs[1:]
	}
}

// counts returns the number of installed, available, and disabled servers
func (m *Model) counts() (installed, available, disabled int) {
	for _, s := range m.allServers {
		switch s.Status {
		case ServerStatusInstalled:
			installed++
		case ServerStatusAvailable:
			available++
		case ServerStatusDisabled:
			disabled++
		}
	}
	return
}

// selectedServer returns the currently highlighted server, or nil if none
func (m *Model) selectedServer() *Server {
	if m.cursor >= 0 && m.cursor < len(m.filteredItems) {
		return &m.filteredItems[m.cursor]
	}
	return nil
}

// Init initializes the model
func (m Model) Init() tea.Cmd {
	return m.spinner.Tick
}

// Update handles messages
func (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	var cmds []tea.Cmd

	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		m.width = msg.Width
		m.height = msg.Height
		m.logViewport.Width = msg.Width - 4
		m.logViewport.Height = 3
		if m.logExpanded {
			m.logViewport.Height = msg.Height / 3
		}

	case spinner.TickMsg:
		var cmd tea.Cmd
		m.spinner, cmd = m.spinner.Update(msg)
		cmds = append(cmds, cmd)

	case serverDeletedMsg:
		m.addLog("success", fmt.Sprintf("Deleted %s", msg.name))
		m.buildServerList()
		m.applyFilter()

	case serverTestedMsg:
		if msg.healthy {
			m.addLog("success", fmt.Sprintf("%s is healthy", msg.name))
		} else {
			m.addLog("error", fmt.Sprintf("%s: %v", msg.name, msg.err))
		}
		// Update health status in the list
		for i := range m.allServers {
			if m.allServers[i].Name == msg.name {
				if msg.healthy {
					m.allServers[i].Health = HealthStatusHealthy
				} else {
					m.allServers[i].Health = HealthStatusUnhealthy
					m.allServers[i].HealthError = msg.err
				}
				break
			}
		}
		m.applyFilter()

	case syncCompletedMsg:
		if len(msg.errors) == 0 {
			m.addLog("success", "Synced to all tools")
		} else {
			m.addLog("warn", fmt.Sprintf("Sync completed with %d errors", len(msg.errors)))
		}

	case serverAddedMsg:
		if msg.err != nil {
			m.addLog("error", fmt.Sprintf("Failed to add %s: %v", msg.name, msg.err))
		} else {
			m.addLog("success", fmt.Sprintf("Installed %s", msg.name))
			m.buildServerList()
			m.applyFilter()
		}

	case serverToggledMsg:
		if msg.err != nil {
			m.addLog("error", fmt.Sprintf("Failed to toggle %s: %v", msg.name, msg.err))
		} else {
			action := "Enabled"
			if msg.disabled {
				action = "Disabled"
			}
			m.addLog("success", fmt.Sprintf("%s %s", action, msg.name))
			m.buildServerList()
			m.applyFilter()
		}

	case editorFinishedMsg:
		if msg.err != nil {
			m.addLog("error", fmt.Sprintf("Editor error: %v", msg.err))
		} else {
			m.addLog("success", "Config updated")
			// Reload config after editing
			if cfg, err := config.LoadWithProject(); err == nil {
				m.cfg = cfg
				m.buildServerList()
				m.applyFilter()
			}
		}

	case tea.KeyMsg:
		// Handle search input mode
		if m.searching {
			switch msg.String() {
			case "esc":
				m.searching = false
				m.searchQuery = ""
				m.applyFilter()
			case "enter":
				m.searching = false
			case "backspace":
				if len(m.searchQuery) > 0 {
					m.searchQuery = m.searchQuery[:len(m.searchQuery)-1]
					m.applyFilter()
				}
			default:
				if len(msg.String()) == 1 {
					m.searchQuery += msg.String()
					m.applyFilter()
				}
			}
			return m, nil
		}

		// Handle help overlay
		if m.showHelp {
			m.showHelp = false
			return m, nil
		}

		// Handle profile picker
		if m.showProfilePicker {
			switch msg.String() {
			case "esc", "q":
				m.showProfilePicker = false
			case "j", "down":
				// +1 for "default" option at index 0
				if m.profileCursor < len(m.profiles) {
					m.profileCursor++
				}
			case "k", "up":
				if m.profileCursor > 0 {
					m.profileCursor--
				}
			case "enter":
				if m.profileCursor == 0 {
					m.profile = "default"
					m.addLog("info", "Switched to default profile")
				} else if m.profileCursor <= len(m.profiles) {
					selectedProfile := m.profiles[m.profileCursor-1]
					m.profile = selectedProfile.Name
					m.addLog("info", fmt.Sprintf("Switched to profile: %s", selectedProfile.Name))
				}
				m.showProfilePicker = false
				m.buildServerList()
				m.applyFilter()
			}
			return m, nil
		}

		switch {
		case key.Matches(msg, m.keys.Quit):
			m.quitting = true
			return m, tea.Quit

		case key.Matches(msg, m.keys.Help):
			m.showHelp = !m.showHelp

		case key.Matches(msg, m.keys.Up):
			if m.cursor > 0 {
				m.cursor--
			}

		case key.Matches(msg, m.keys.Down):
			if m.cursor < len(m.filteredItems)-1 {
				m.cursor++
			}

		case key.Matches(msg, m.keys.Top):
			m.cursor = 0

		case key.Matches(msg, m.keys.Bottom):
			m.cursor = max(0, len(m.filteredItems)-1)

		case key.Matches(msg, m.keys.PageDown):
			m.cursor = min(m.cursor+10, len(m.filteredItems)-1)

		case key.Matches(msg, m.keys.PageUp):
			m.cursor = max(m.cursor-10, 0)

		case key.Matches(msg, m.keys.Search):
			m.searching = true
			m.searchQuery = ""

		case key.Matches(msg, m.keys.Escape):
			m.searchQuery = ""
			m.selected = make(map[string]bool)
			m.applyFilter()

		case key.Matches(msg, m.keys.Select):
			if s := m.selectedServer(); s != nil {
				m.selected[s.Name] = !m.selected[s.Name]
				if !m.selected[s.Name] {
					delete(m.selected, s.Name)
				}
			}

		case key.Matches(msg, m.keys.SelectAll):
			allSelected := true
			for _, s := range m.filteredItems {
				if !m.selected[s.Name] {
					allSelected = false
					break
				}
			}
			if allSelected {
				m.selected = make(map[string]bool)
			} else {
				for _, s := range m.filteredItems {
					m.selected[s.Name] = true
				}
			}

		case key.Matches(msg, m.keys.Install):
			if s := m.selectedServer(); s != nil && s.Status == ServerStatusAvailable {
				m.addLog("info", fmt.Sprintf("Installing %s...", s.Name))
				return m, m.addServer(s.Name)
			}

		case key.Matches(msg, m.keys.Delete):
			if s := m.selectedServer(); s != nil && s.Status != ServerStatusAvailable {
				return m, m.deleteServer(s.Name)
			}

		case key.Matches(msg, m.keys.Edit):
			if s := m.selectedServer(); s != nil && s.Status != ServerStatusAvailable {
				m.addLog("info", fmt.Sprintf("Opening editor for %s...", s.Name))
				return m, m.editServer(s.Name)
			}

		case key.Matches(msg, m.keys.Toggle):
			if s := m.selectedServer(); s != nil && s.Status != ServerStatusAvailable {
				return m, m.toggleServer(s.Name)
			}

		case key.Matches(msg, m.keys.Sync):
			if s := m.selectedServer(); s != nil {
				m.addLog("info", fmt.Sprintf("Syncing %s...", s.Name))
			}
			return m, m.syncAll()

		case key.Matches(msg, m.keys.SyncAll):
			m.addLog("info", "Syncing all servers...")
			return m, m.syncAll()

		case key.Matches(msg, m.keys.Test):
			if s := m.selectedServer(); s != nil && s.Status != ServerStatusAvailable {
				m.addLog("info", fmt.Sprintf("Testing %s...", s.Name))
				// Mark as checking
				for i := range m.allServers {
					if m.allServers[i].Name == s.Name {
						m.allServers[i].Health = HealthStatusChecking
						break
					}
				}
				m.applyFilter()
				return m, m.testServer(s.Name)
			}

		case key.Matches(msg, m.keys.TestAll):
			m.addLog("info", "Testing all installed servers...")
			return m, m.testAllServers()

		case key.Matches(msg, m.keys.Refresh):
			m.buildServerList()
			m.applyFilter()
			m.addLog("info", "Refreshed server list")

		case key.Matches(msg, m.keys.CycleFilter):
			m.filterMode = (m.filterMode + 1) % 4
			m.applyFilter()

		case key.Matches(msg, m.keys.FilterAll):
			m.filterMode = FilterAll
			m.applyFilter()

		case key.Matches(msg, m.keys.FilterInstalled):
			m.filterMode = FilterInstalled
			m.applyFilter()

		case key.Matches(msg, m.keys.FilterAvailable):
			m.filterMode = FilterAvailable
			m.applyFilter()

		case key.Matches(msg, m.keys.FilterDisabled):
			m.filterMode = FilterDisabled
			m.applyFilter()

		case key.Matches(msg, m.keys.ToggleLogs):
			m.logExpanded = !m.logExpanded
			if m.logExpanded {
				m.logViewport.Height = m.height / 3
			} else {
				m.logViewport.Height = 3
			}

		case key.Matches(msg, m.keys.ProfileSwitch):
			m.showProfilePicker = true
			m.profileCursor = 0
			// Find current profile index
			for i, p := range m.profiles {
				if p.Name == m.profile {
					m.profileCursor = i + 1 // +1 for default at index 0
					break
				}
			}
		}
	}

	return m, tea.Batch(cmds...)
}

// View renders the UI
func (m Model) View() string {
	if m.quitting {
		return ""
	}

	if m.showHelp {
		return m.renderHelpOverlay()
	}

	if m.showProfilePicker {
		return m.renderProfilePicker()
	}

	var sections []string

	// Header
	sections = append(sections, m.renderHeader())

	// Divider
	sections = append(sections, m.renderDivider())

	// Server list
	sections = append(sections, m.renderServerList())

	// Divider
	sections = append(sections, m.renderDivider())

	// Log panel
	sections = append(sections, m.renderLogPanel())

	// Divider
	sections = append(sections, m.renderDivider())

	// Key hints
	sections = append(sections, m.renderKeyHints())

	return lipgloss.JoinVertical(lipgloss.Left, sections...)
}

// renderHeader renders the header bar
func (m *Model) renderHeader() string {
	installed, available, disabled := m.counts()

	// Left: App name
	title := HeaderTitleStyle.Render("agentctl")

	// Center: Profile info
	profileInfo := HeaderSubtitleStyle.Render(fmt.Sprintf("%s (%d servers)", m.profile, len(m.allServers)))

	// Right: Status counts
	counts := fmt.Sprintf("%s %d  %s %d  %s %d",
		StatusInstalledStyle.Render(StatusInstalled), installed,
		StatusAvailableStyle.Render(StatusAvailable), available,
		StatusDisabledStyle.Render(StatusDisabled), disabled,
	)

	// Calculate spacing
	leftWidth := lipgloss.Width(title)
	centerWidth := lipgloss.Width(profileInfo)
	rightWidth := lipgloss.Width(counts)
	totalContent := leftWidth + centerWidth + rightWidth

	availableSpace := m.width - totalContent - 4
	if availableSpace < 0 {
		availableSpace = 0
	}
	leftPad := availableSpace / 2
	rightPad := availableSpace - leftPad

	header := title + strings.Repeat(" ", leftPad) + profileInfo + strings.Repeat(" ", rightPad) + counts

	return HeaderStyle.Width(m.width).Render(header)
}

// renderDivider renders a horizontal divider
func (m *Model) renderDivider() string {
	return lipgloss.NewStyle().
		Foreground(colorFgSubtle).
		Width(m.width).
		Render(strings.Repeat("─", m.width))
}

// renderServerList renders the main server list
func (m *Model) renderServerList() string {
	var rows []string

	// Calculate available height for list
	listHeight := m.height - 12 // Account for header, log panel, hints, dividers
	if m.logExpanded {
		listHeight = m.height - 8 - m.height/3
	}
	if listHeight < 5 {
		listHeight = 5
	}

	// Search bar if searching
	if m.searching {
		searchBar := SearchPromptStyle.Render("/") + SearchInputStyle.Render(m.searchQuery+"█")
		rows = append(rows, SearchStyle.Width(m.width-4).Render(searchBar))
		listHeight--
	}

	// Filter indicator
	filterLabel := ""
	switch m.filterMode {
	case FilterAll:
		filterLabel = "All"
	case FilterInstalled:
		filterLabel = "Installed"
	case FilterAvailable:
		filterLabel = "Available"
	case FilterDisabled:
		filterLabel = "Disabled"
	}
	if filterLabel != "" && m.filterMode != FilterAll {
		filterText := lipgloss.NewStyle().Foreground(colorCyan).Render("Filter: " + filterLabel)
		rows = append(rows, "  "+filterText)
		listHeight--
	}

	if len(m.filteredItems) == 0 {
		emptyMsg := lipgloss.NewStyle().
			Foreground(colorFgSubtle).
			Italic(true).
			Render("No servers match the current filter")
		rows = append(rows, "  "+emptyMsg)
	} else {
		// Calculate visible range
		startIdx := 0
		if m.cursor >= listHeight {
			startIdx = m.cursor - listHeight + 1
		}
		endIdx := min(startIdx+listHeight, len(m.filteredItems))

		for i := startIdx; i < endIdx; i++ {
			server := m.filteredItems[i]
			row := m.renderServerRow(server, i == m.cursor)
			rows = append(rows, row)
		}
	}

	// Pad to fill height
	for len(rows) < listHeight {
		rows = append(rows, "")
	}

	return lipgloss.JoinVertical(lipgloss.Left, rows...)
}

// renderServerRow renders a single server row
func (m *Model) renderServerRow(s Server, selected bool) string {
	// Selection indicator
	selectIndicator := "  "
	if m.selected[s.Name] {
		selectIndicator = ListCursorStyle.Render("▶ ")
	}

	// Status badge (styled)
	var statusBadge string
	switch s.Status {
	case ServerStatusInstalled:
		statusBadge = StatusInstalledStyle.Render(StatusInstalled)
	case ServerStatusAvailable:
		statusBadge = StatusAvailableStyle.Render(StatusAvailable)
	case ServerStatusDisabled:
		statusBadge = StatusDisabledStyle.Render(StatusDisabled)
	}

	// Server name
	nameStyle := ListItemNameStyle
	if selected {
		nameStyle = ListItemNameSelectedStyle
	}
	name := nameStyle.Render(s.Name)

	// Health indicator
	var healthBadge string
	switch s.Health {
	case HealthStatusHealthy:
		healthBadge = HealthHealthyStyle.Render(" " + HealthHealthy)
	case HealthStatusUnhealthy:
		healthBadge = HealthUnhealthyStyle.Render(" " + HealthUnhealthy)
	case HealthStatusChecking:
		healthBadge = HealthCheckingStyle.Render(" " + m.spinner.View())
	}

	// Description
	descStyle := ListItemDescStyle
	if selected {
		descStyle = ListItemDescSelectedStyle
	}
	desc := descStyle.Render(s.Transport + " · " + truncate(s.Description(), 50))

	// Build the row
	leftPart := selectIndicator + statusBadge + " " + name + healthBadge

	// Calculate padding for right-aligned description
	leftWidth := lipgloss.Width(leftPart)
	descWidth := lipgloss.Width(desc)
	padding := m.width - leftWidth - descWidth - 4
	if padding < 2 {
		padding = 2
	}

	row := leftPart + strings.Repeat(" ", padding) + desc

	// Apply selection styling
	if selected {
		row = ListItemSelectedStyle.Width(m.width).Render(row)
	} else {
		row = ListItemNormalStyle.Width(m.width).Render(row)
	}

	return row
}

// renderLogPanel renders the log panel
func (m *Model) renderLogPanel() string {
	var logLines []string

	// Determine how many log entries to show
	numLogs := 3
	if m.logExpanded {
		numLogs = m.height / 3
	}

	startIdx := max(0, len(m.logs)-numLogs)
	for i := startIdx; i < len(m.logs); i++ {
		entry := m.logs[i]
		timeStr := LogTimestampStyle.Render(entry.Time.Format("15:04:05"))

		var levelStyle lipgloss.Style
		var symbol string
		switch entry.Level {
		case "success":
			levelStyle = LogEntryInfoStyle.Foreground(colorTeal)
			symbol = "✓"
		case "error":
			levelStyle = LogEntryErrorStyle
			symbol = "✗"
		case "warn":
			levelStyle = LogEntryWarnStyle
			symbol = "⚠"
		default:
			levelStyle = LogEntryInfoStyle
			symbol = "↻"
		}

		logLine := timeStr + "  " + levelStyle.Render(symbol+" "+entry.Message)
		logLines = append(logLines, logLine)
	}

	// Pad if needed
	for len(logLines) < numLogs {
		logLines = append([]string{""}, logLines...)
	}

	return lipgloss.JoinVertical(lipgloss.Left, logLines...)
}

// renderKeyHints renders the bottom key hints bar
func (m *Model) renderKeyHints() string {
	hints := []struct{ Key, Desc string }{
		{"j/k", "navigate"},
		{"i", "install"},
		{"d", "delete"},
		{"e", "edit"},
		{"s", "sync"},
		{"/", "search"},
		{"?", "help"},
	}

	return RenderKeyHintsBar(hints)
}

// renderHelpOverlay renders the full help overlay
func (m *Model) renderHelpOverlay() string {
	content := `
  Navigation           Operations           Filters
  ──────────           ──────────           ───────
  j/k     up/down      i      install       f    cycle filter
  g/G     top/bottom   d      delete        1    all
  /       search       e      edit          2    installed
  Esc     clear        Enter  toggle        3    available
                       s      sync          4    disabled
  Selection            t      test
  ─────────                                 UI
  Space   toggle       Profiles             ──
  V       select all   ────────             L    toggle logs
                       P      switch        ?    this help
                                            q    quit

                       Press any key to close
`

	return ModalStyle.
		Width(60).
		Render(ModalTitleStyle.Render("Keyboard Shortcuts") + content)
}

// renderProfilePicker renders the profile quick-switcher modal
func (m *Model) renderProfilePicker() string {
	var rows []string

	// Add "default" option at index 0
	cursor := "  "
	if m.profileCursor == 0 {
		cursor = "> "
	}
	defaultLabel := "default"
	if m.profile == "default" {
		defaultLabel += " (current)"
	}
	if m.profileCursor == 0 {
		rows = append(rows, ListItemSelectedStyle.Render(cursor+defaultLabel+" (all servers)"))
	} else {
		rows = append(rows, ListItemNormalStyle.Render(cursor+defaultLabel+" (all servers)"))
	}

	// Add user profiles
	for i, p := range m.profiles {
		cursor := "  "
		idx := i + 1 // +1 for default at index 0
		if m.profileCursor == idx {
			cursor = "> "
		}

		label := p.Name
		if m.profile == p.Name {
			label += " (current)"
		}
		desc := ""
		if len(p.Servers) > 0 {
			desc = fmt.Sprintf(" (%d servers)", len(p.Servers))
		}

		row := cursor + label + desc
		if m.profileCursor == idx {
			rows = append(rows, ListItemSelectedStyle.Render(row))
		} else {
			rows = append(rows, ListItemNormalStyle.Render(row))
		}
	}

	if len(m.profiles) == 0 {
		rows = append(rows, "")
		rows = append(rows, ListItemDimmedStyle.Render("  No profiles found"))
		rows = append(rows, ListItemDimmedStyle.Render("  Use 'agentctl profile create' to add one"))
	}

	content := lipgloss.JoinVertical(lipgloss.Left, rows...)

	hints := "\n\n" + KeyDescStyle.Render("j/k:navigate  Enter:select  Esc:cancel")

	return ModalStyle.
		Width(40).
		Render(ModalTitleStyle.Render("Switch Profile") + "\n\n" + content + hints)
}

// Helper functions

func truncate(s string, max int) string {
	if len(s) <= max {
		return s
	}
	return s[:max-3] + "..."
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

// Messages

type serverDeletedMsg struct {
	name string
}

type serverTestedMsg struct {
	name    string
	healthy bool
	err     error
}

type syncCompletedMsg struct {
	errors map[string]error
}

type serverAddedMsg struct {
	name string
	err  error
}

type serverToggledMsg struct {
	name     string
	disabled bool
	err      error
}

type editorFinishedMsg struct {
	err error
}

// Commands

func (m *Model) deleteServer(name string) tea.Cmd {
	return func() tea.Msg {
		delete(m.cfg.Servers, name)
		if err := m.cfg.Save(); err != nil {
			return serverDeletedMsg{name: name}
		}
		return serverDeletedMsg{name: name}
	}
}

func (m *Model) testServer(name string) tea.Cmd {
	return func() tea.Msg {
		server, ok := m.cfg.Servers[name]
		if !ok {
			return serverTestedMsg{name: name, healthy: false, err: fmt.Errorf("server not found")}
		}

		if server.Disabled {
			return serverTestedMsg{name: name, healthy: false, err: fmt.Errorf("server is disabled")}
		}

		// Handle remote HTTP/SSE servers
		if server.Transport == mcp.TransportHTTP || server.Transport == mcp.TransportSSE {
			// For remote servers, just check if URL is reachable
			// Note: A full implementation would do an actual MCP handshake
			if server.URL == "" {
				return serverTestedMsg{name: name, healthy: false, err: fmt.Errorf("no URL configured")}
			}
			return serverTestedMsg{name: name, healthy: true}
		}

		// Handle stdio servers
		if server.Command == "" {
			return serverTestedMsg{name: name, healthy: false, err: fmt.Errorf("no command configured")}
		}

		// Resolve environment variables
		env := make(map[string]string)
		if server.Env != nil {
			var resolveErr error
			env, resolveErr = secrets.ResolveEnv(server.Env)
			if resolveErr != nil {
				return serverTestedMsg{name: name, healthy: false, err: resolveErr}
			}
		}

		// Try to start the server with timeout
		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		defer cancel()

		execCmd := exec.CommandContext(ctx, server.Command, server.Args...)

		// Set environment
		for k, v := range env {
			execCmd.Env = append(execCmd.Env, fmt.Sprintf("%s=%s", k, v))
		}

		// Try to start and quickly check if it fails
		err := execCmd.Start()
		if err != nil {
			return serverTestedMsg{name: name, healthy: false, err: err}
		}

		// Give it a moment to fail or succeed
		done := make(chan error, 1)
		go func() {
			done <- execCmd.Wait()
		}()

		select {
		case <-time.After(500 * time.Millisecond):
			// Server is still running after 500ms, consider it healthy
			execCmd.Process.Kill()
			return serverTestedMsg{name: name, healthy: true}
		case err := <-done:
			if err != nil {
				if ctx.Err() == context.DeadlineExceeded {
					return serverTestedMsg{name: name, healthy: true}
				}
				return serverTestedMsg{name: name, healthy: false, err: err}
			}
			// Exited with 0, might be a short-lived command
			return serverTestedMsg{name: name, healthy: true}
		case <-ctx.Done():
			execCmd.Process.Kill()
			return serverTestedMsg{name: name, healthy: true}
		}
	}
}

func (m *Model) testAllServers() tea.Cmd {
	return func() tea.Msg {
		// This just starts the batch - individual results will come via testServer
		return syncCompletedMsg{errors: make(map[string]error)}
	}
}

func (m *Model) syncAll() tea.Cmd {
	return func() tea.Msg {
		// Build server list from config
		var servers []*mcp.Server
		for _, server := range m.cfg.Servers {
			if !server.Disabled {
				servers = append(servers, server)
			}
		}

		// Sync to all detected tools
		results := sync.SyncAll(servers, nil, nil)

		errors := make(map[string]error)
		for _, result := range results {
			if result.Error != nil {
				errors[result.Tool] = result.Error
			}
		}

		return syncCompletedMsg{errors: errors}
	}
}

func (m *Model) toggleServer(name string) tea.Cmd {
	return func() tea.Msg {
		server, ok := m.cfg.Servers[name]
		if !ok {
			return serverToggledMsg{name: name, err: fmt.Errorf("server not found")}
		}

		server.Disabled = !server.Disabled
		if err := m.cfg.Save(); err != nil {
			return serverToggledMsg{name: name, err: err}
		}

		return serverToggledMsg{name: name, disabled: server.Disabled}
	}
}

func (m *Model) editServer(name string) tea.Cmd {
	// Use project config if available, otherwise global config
	configPath := m.cfg.Path
	if m.cfg.ProjectPath != "" {
		configPath = m.cfg.ProjectPath
	}

	// Determine editor
	editor := os.Getenv("EDITOR")
	if editor == "" {
		editor = os.Getenv("VISUAL")
	}
	if editor == "" {
		editor = "vi" // fallback
	}

	// Use tea.ExecProcess to run the editor
	c := exec.Command(editor, configPath)
	return tea.ExecProcess(c, func(err error) tea.Msg {
		return editorFinishedMsg{err: err}
	})
}

func (m *Model) addServer(name string) tea.Cmd {
	return func() tea.Msg {
		// Resolve alias
		alias, ok := aliases.Resolve(name)
		if !ok {
			return serverAddedMsg{name: name, err: fmt.Errorf("unknown alias %q", name)}
		}

		// Build server config from alias
		server := &mcp.Server{
			Name: name,
			Source: mcp.Source{
				Type:  "alias",
				Alias: name,
				URL:   alias.URL,
			},
		}

		// Handle remote HTTP/SSE MCP servers
		if alias.Transport == "http" || alias.Transport == "sse" {
			server.Transport = mcp.Transport(alias.Transport)
			server.URL = alias.MCPURL
			server.Source.URL = alias.MCPURL
			server.Source.Type = "remote"
		} else {
			// Local server with stdio transport
			server.Transport = mcp.TransportStdio
			packageName := alias.Package
			if packageName == "" {
				packageName = name
			}
			switch alias.Runtime {
			case "node":
				server.Command = "npx"
				server.Args = []string{"-y", packageName}
			case "python":
				server.Command = "uvx"
				server.Args = []string{packageName}
			default:
				server.Command = "npx"
				server.Args = []string{"-y", packageName}
			}
		}

		// Add to config
		if m.cfg.Servers == nil {
			m.cfg.Servers = make(map[string]*mcp.Server)
		}
		m.cfg.Servers[name] = server

		// Save config
		if err := m.cfg.Save(); err != nil {
			return serverAddedMsg{name: name, err: err}
		}

		return serverAddedMsg{name: name, err: nil}
	}
}

// Run starts the TUI application
func Run() error {
	m, err := New()
	if err != nil {
		return err
	}

	p := tea.NewProgram(m, tea.WithAltScreen())
	_, err = p.Run()
	return err
}
